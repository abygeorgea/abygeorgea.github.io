<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Postman | Aby George A]]></title>
  <link href="http://www.abygeorgea.com/blog/categories/postman/atom.xml" rel="self"/>
  <link href="http://www.abygeorgea.com/"/>
  <updated>2018-05-27T09:26:50+10:00</updated>
  <id>http://www.abygeorgea.com/</id>
  <author>
    <name><![CDATA[Aby George A]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running API Test Using Cypress]]></title>
    <link href="http://www.abygeorgea.com/blog/2018/05/27/running-api-test-using-cypress/"/>
    <updated>2018-05-27T08:03:28+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2018/05/27/running-api-test-using-cypress</id>
    <content type="html"><![CDATA[<p>Cypress is not just UI automation tool . It can be used for testing APIs as well . Even though we have other tools like Postman, Newman, Rest Assured, SOAP UI etc for testing APIs, I believe cypress is a good alternative for testing API. It will help to use same tool for both UI and API test automation.</p>

<h2>Demo</h2>

<p>Let us look at a sample API test case. In below example, we trigger a API call to <code>http://services.groupkt.com/country/get/iso2code/AU</code> and validate below in the response.</p>

<ul>
<li>Status code of response is 200.</li>
<li>Header include &lsquo;application/json&rsquo;.</li>
<li>Body contain &ldquo;Country found matching code [AU].&rdquo;</li>
</ul>


<p>We can then extend this to do any further checks if needed.</p>

<p>Create a new file inside <code>Integration</code> folder of cypress and copy below code into that.</p>

<pre><code>describe('API Testing with Cypress', () =&gt; {
    var result

    it('Validate the header', () =&gt; {
       result = cy.request('http://services.groupkt.com/country/get/iso2code/AU')

       result.its('headers')
             .its('content-type')
             .should('include', 'application/json')

    })

    it('Validate the status', () =&gt; {
        result = cy.request('http://services.groupkt.com/country/get/iso2code/AU')

        result.its('status')
              .should('equal',200);
     })

     it('Validate the body ', () =&gt; {
        result = cy.request('http://services.groupkt.com/country/get/iso2code/AU')

        result.its('body')
              .its('RestResponse.messages')
              .should('include', 'Country found matching code [AU].');

     })
}) 
</code></pre>

<p>Open Cypress by running <code>node_modules/.bin/cypress open</code> inside cypress root folder. This will open up Cypress.</p>

<p>Run newly created test.</p>

<p><img src="/images/2018/05/27/01%20Run%20Test%20Case.png" alt="APITestingWithCypress" /></p>

<p>Results of test execution will look like below.</p>

<p><img src="/images/2018/05/27/02%20Check%20Result.png" alt="[APITestingWithCypress]" /></p>

<p>Expand each of them and right click on the asserts and inspect the element. This will open up chrome developer tool. Select the console tab , which will list down details of calls made, request received and assertions performed.  It will help to write additional assertions, investigate any failure etc.</p>

<p><img src="/images/2018/05/27/03%20Expand%20and%20Analyse%20result.png" alt="[APITestingWithCypress]" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Tests in Postman]]></title>
    <link href="http://www.abygeorgea.com/blog/2018/05/03/writing-tests-in-postman/"/>
    <updated>2018-05-03T21:05:00+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2018/05/03/writing-tests-in-postman</id>
    <content type="html"><![CDATA[<p>In previous blog <a href="/blog/2018/04/28/postman-bdd/">post</a>, we saw how to use BDD format for writing test cases in postman. Most important part of writing tests in postman is understanding various features available. Let us explore various options available . The examples specified in postman <a href="https://documenter.getpostman.com/view/220187/postman-bdd-examples/6Z3uY71#30dfc9d2-5de4-b932-db3e-641c29fb0459">documentation</a>, have lot of information about how to setup postman bdd, use chai http assertions, create custom assertions and use before and after hooks. Please import them into postman and try that by yourself to familiarise with postman BDD. Below is only few examples from them.</p>

<p>Postman BDD makes use of Chai Assertion Library and Chai-Http. We have access to both libray and postman scripting environment for writing test cases. Chai has two types of assertion styles.</p>

<ul>
<li><code>Expect/should</code> for BDD</li>
<li><code>Assert</code> for TDD</li>
</ul>


<p>Both styles support chainable language to construct assertions. We can use both of them to write postman test assertions. If you need details of all chainable constructs, please refer to their <a href="http://www.chaijs.com/api/bdd/">documentation</a>. Major ones which we may use in postman tests are</p>

<ul>
<li><p>Chains</p>

<pre><code>  to
  be
  been
  is
  that
  which
  and
  has
  have
  with
  at
  of
  same
  but
  does
</code></pre></li>
<li><p>Not - Negates all conditions</p></li>
<li>any -</li>
<li>all -</li>
<li>inlcude</li>
<li>OK</li>
<li>true</li>
<li>false</li>
<li>null</li>
<li>undefined</li>
<li>exist</li>
<li>empty</li>
<li>match(re[, msg])</li>
</ul>


<p>Chai-Http module provide various assertions. Read through their documentation <a href="https://github.com/chaijs/chai-http#assertions">here</a> to know details. Below are main commands at our disposal for validation .</p>

<ul>
<li>.status(code)</li>
<li>.header (key[, value])</li>
<li>.headers</li>
<li>.ip</li>
<li>.json / .text / .html</li>
<li>.redirect</li>
<li>.param</li>
<li>.cookie</li>
</ul>


<p>Postman bdd provide <code>response</code> object on which we do most of assertions. It will have all information like response.text, response.body, response.status, response.ok , response.error. Postman BDD will automatically parse JSON and XML responses and hence there is no need to call JSON.parse() or xml2json(). response.text will have unparsed content. It also have automatic error handling , which will allow to continue with other test even if something fails.</p>

<p>Examples for various assertions done on response object are below</p>

<pre><code>\\Verifying Header information
expect(response).to.have.status(500);
expect(response).to.have.header('x-api-key');
expect(response).to.have.header('content-type', 'text/plain');
expect(request).to.have.header('content-type', /^text/);
expect(response).to.have.headers;
expect('127.0.0.1').to.be.an.ip;

\\Verifying Response body
expect(response).to.be.json;
expect(response).to.be.html;
expect(response).to.be.text;

response.should.have.status(200); 
response.body.should.not.be.empty;
response.ok.should.be.true;            // sucess with code 2XX
response.error.should.be.true; //failures

\\Verifying request
expect(req).to.have.param('orderby', 'date');
expect(req).to.not.have.param('orderby');
expect(req).to.have.cookie('session_id', '1234');
expect(req).to.not.have.cookie('PHPSESSID');
</code></pre>

<p>If we use above assertions in proper BDD format, it will look like below</p>

<pre><code>eval(globals.postmanBDD);
describe('Example for Blog using SHOULD', function(){
   it("Tests using SHOULD", function() {
      response.should.have.status(200); 
      response.should.not.be.empty;
      response.should.have.header('content-type', 'application/json; charset=utf-8');
      response.type.should.equal('application/json');

      var user = response.body.results[0];
      user.name.should.be.an('object');
      user.name.should.have.property('first').and.not.empty;
      //user.name.should.have.property('first','david');
      user.should.have.property('gender','male');


   }) 
})
describe('Example for Blog using Expect', function(){
   it("Tests using EXPECT", function() {
      expect(response).to.have.status(200);
      expect(response).not.empty;
      expect(response).to.be.json;
      expect(response).to.have.header('content-type', 'application/json; charset=utf-8');
   }) 
})

it('should contain the un-parsed JSON text', () =&gt; {
    response.text.should.be.a('string').with.length.above(50);
    response.text.should.contain('"results":[');
});
</code></pre>

<p><img src="/images/2018/05/03/postman%20bdd.png" alt="Postman" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postman BDD]]></title>
    <link href="http://www.abygeorgea.com/blog/2018/04/28/postman-bdd/"/>
    <updated>2018-04-28T07:46:43+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2018/04/28/postman-bdd</id>
    <content type="html"><![CDATA[<p>In Previous blog post,we discussed about <a href="/blog/2017/08/05/postman-tutorial/">how to use postman</a> and how to use <a href="/blog/2017/08/07/running-postman-collection-using-newman/">collections using newman </a>and <a href="/blog/2017/08/13/postman-using-data-file">data file</a>. If you haven&rsquo;t read that , please have a read through first .</p>

<p>In previous examples, we discussed about writing tests/assertions in postman. We followed normal Javascript syntax for writing test cases including asserting various factors of response ( like content , status code etc). Eventhough this is a straightforward way of writing, many people would like to use existing javascript test library like Mocha. They can use <a href="https://github.com/BigstickCarpet/postman-bdd/#installation">postman - bdd</a> libraries.</p>

<p>Let us take a deep dive into how to use setup postman bdd.</p>

<p>Note: It is assumed that user already have postman and newman installed on their machine along with their dependencies.</p>

<h2>Installing Postman BDD</h2>

<p>Installation is done triggering a Get request and setting the response as Global environment variable.</p>

<ul>
<li>Create a GET request to <code>http://bigstickcarpet.com/postman-bdd/dist/postman-bdd.js</code></li>
<li>Set Global environment variable by using below command in test tab. <code>postman.setGlobalVariable('postmanBDD', responseBody);</code></li>
</ul>


<p><img src="/images/2018/04/28/Installing%20Postman%20BDD.png" alt="PostManRequest" /></p>

<p>Once we trigger above get request, postman bdd will be available for use.  We can make use of postman BDD features by below command
<code>eval(globals.postmanBDD);</code></p>

<h2>Writing Tests</h2>

<p>Postman bdd library provide us with flexibility to write tests and assertions using fluent asserts and have best features of Chai and Mocha. Inorder to demonstrate this, I am using sample Tutorial given with postman client.</p>

<p>Open up the sample Request in Postman Tutorial folder under collections. It will already have some test predefined in Test tab. Remove them and add below test to it.</p>

<pre><code>eval(globals.postmanBDD)
//eval(postman.getGlobalVariable('postmanBDD'));
var jsonData = JSON.parse(responseBody);
describe('Testing Sample Request in Postman Tutorial', function () {
    it('CASE 1: Should respond with statusCode = 200', function () {
        response.should.have.status(200);
    });
    it('CASE 2: Should response time less than 500 ms', function () {
        pm.response.responseTime.should.be.below(500);
    });
    it('CASE 3: User ID should be 1', function () {
        jsonData.userId === 1;
    });

});
</code></pre>

<p>Note: You can find more details of various type of asserts in <a href="http://www.chaijs.com/api/bdd/">http://www.chaijs.com/api/bdd/</a></p>

<p>Once it is done, trigger the request</p>

<p><img src="/images/2018/04/28/Postman%20BDD%20example.png" alt="PostManRequest" />.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postman - Using Data File]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/08/13/postman-using-data-file/"/>
    <updated>2017-08-13T20:56:01+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/08/13/postman-using-data-file</id>
    <content type="html"><![CDATA[<p>One of the common requirement for automated testing is to run same test case against multiple test data. Luckily postman supports this by providing facility to use data files. This is available only when we run through postman collection runner or newman.</p>

<p>For this example, let us take a free public API <code>http://services.groupkt.com/country/get/iso2code/AU</code> . This API will return the name of the country depending on the 2 digit code passed. Let us assume that, we need to test this API with multiple country codes. For eg: AU, IN, GB etc.  Let us take a look to see how this can be achieved using postman data files.</p>

<h4>Environment file</h4>

<p>First, create an enviornment Manage Environment option at top right. Create an entry for endpoint as below.</p>

<p><img src="/images/2017/08/13/PostmanDatafile%201.png" alt="EnivironmentSetup" /></p>

<h4>Create Collection</h4>

<p>Next step is to create a collection with a GET request and write tests to verify the response. GET request used here is <code>{EndPoint}/country/get/iso2code/{countrycode}</code></p>

<p>Endpoint is defined in environment file and countrycode will be in data file</p>

<p>Now write some tests to check the results. The data coming from data file will be available under &ldquo;data&rdquo; dictionary  ( similar to global/environment variable. It can be accessed as <code>data.VARIABLENAME</code> or <code>data["VARIABLENAME"]</code> in both test and pre requisite scripts. Below screenshot shows the test which is for validating country name based on the data file.</p>

<p><img src="/images/2017/08/13/PostmanDatafile%202.png" alt="EnivironmentSetup" /></p>

<h4>DateFile</h4>

<p>Postman supports both CSV and JSON format. For CSV files, the first row should be the variable names as the header. All subsequent rows are data row. JSON file should be an array of the keyvalue pair where the variable name is the key.</p>

<p>Data file used in this example is below. It has 3 column, where the first column is test case ID and the second one is country code which is used in the request and the third one is the country name, which is used for asserting the response received. In this example, I am looking for 3 different country codes.</p>

<p><img src="/images/2017/08/13/PostmanDatafile%203.png" alt="datafile" /></p>

<h4>Running Collections</h4>

<p>While running collections, we need to specify below inputs.</p>

<ul>
<li>Collection Name</li>
<li>Environment file</li>
<li>Data File</li>
</ul>


<p>Depending on number of records in the data file, iterations will be auto populated. The results will also show the details for each iteration using the data. Details of response can be found by expanding response body</p>

<p><img src="/images/2017/08/13/PostmanDatafile%204.png" alt="collection" /></p>

<p><img src="/images/2017/08/13/PostmanDatafile%205.png" alt="result" /></p>

<h4>Running through Newman</h4>

<p>We can run same collection through Newman as well</p>

<pre><code>newman run PathToCollectionsFile -e PathToEnvironmentFiles -d PathToDataFile
</code></pre>

<p>In this cases, I should run <code>newman run DataDriven.postman_collection.json -e DataDrivenEnvironment.postman_environment.json   -d data-article.csv</code>.</p>

<p>Results will be as below</p>

<p><img src="/images/2017/08/13/PostmanDatafile%206.png" alt="NewmanResults" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running Postman Collection Using Newman]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/08/07/running-postman-collection-using-newman/"/>
    <updated>2017-08-07T15:46:28+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/08/07/running-postman-collection-using-newman</id>
    <content type="html"><![CDATA[<p>In previous <a href="/blog/2017/08/05/postman-tutorial/">blog</a>, I explained about how to create a GET request, analyze its response, write test cases for API and to save details to a collection for future use. In this blog, let me explain about how to run collections using Newman.</p>

<h3>What is Newman</h3>

<p>Newman is a command line collection runner for postman. Newman also has feature parity with Postman and it runs collection in the same way how it is run through Postman. Newman also makes it easier to integrate API test case execution with other systems like Jenkins.</p>

<h3>Installing Newman</h3>

<p>Newman is built on Node.js and hence it requires Node.js to be installed as prerequisite. Newman can be installed from npm with below command</p>

<pre><code>$ npm install -g newman
</code></pre>

<h3>Running collection using Newman</h3>

<p>Collections are executed by calling run command in Newman. Basic command for executing collections is</p>

<pre><code>newman run PathToCollectionFile -e PathToEnvironmentFileIfAny
</code></pre>

<p>Below is an example of running collections created in previous blog post using newman.
Command will look like below
<code>newman run /Users/abygeorgea/Projects/Postman/Postman\ Tutorial.postman_collection.json -e /Users/abygeorgea/Projects/Postman/Test.postman_environment.json</code></p>

<h3>Results</h3>

<p>The result of API test case execution will look like below. It has a detailed report of number of iterations, number of request, test scripts, pre-requisites, assertions etc. As per standard, passed ones are shown in green and failed in red. The results look similar to details provided if collections are executed using postman.</p>

<p><img src="/images/2017/08/07/Newman%201.png" alt="NewmanResult" /></p>

<h3>Additional Options of run command</h3>

<p>Newman has various options to customize run. Different options can be found by running with <code>-h</code> flag</p>

<pre><code>newman run -h
</code></pre>

<p>Different options listed are below</p>

<pre><code>Abys-MacBook-Pro:~ abygeorgea$ newman run -h
usage: newman run [-h] [-v VERSION] [--no-color] [--color]
                  [--timeout-request TIMEOUT_REQUEST] [--ignore-redirects]
                  [-k] [--ssl-client-cert SSL_CLIENT_CERT]
                  [--ssl-client-key SSL_CLIENT_KEY]
                  [--ssl-client-passphrase SSL_CLIENT_PASSPHRASE]
                  [-e ENVIRONMENT] [-g GLOBALS] [--folder FOLDER]
                  [-r REPORTERS] [-n ITERATION_COUNT] [-d ITERATION_DATA]
                  [--export-environment [EXPORT_ENVIRONMENT]]
                  [--export-globals [EXPORT_GLOBALS]]
                  [--export-collection [EXPORT_COLLECTION]]
                  [--delay-request DELAY_REQUEST] [--bail] [-x] [--silent]
                  [--disable-unicode] [--global-var GLOBAL_VAR]
                  collection

The "run" command can be used to run Postman Collections

Positional arguments:
  collection            URL or path to a Postman Collection

Optional arguments:
  -h, --help            Show this help message and exit.
  -v VERSION, --version VERSION
                        Display the newman version
  --no-color            Disable colored output
  --color               Force colored output (for use in CI environments)
  --timeout-request TIMEOUT_REQUEST
                        Specify a timeout for requests (in milliseconds)
  --ignore-redirects    If present, Newman will not follow HTTP Redirects
  -k, --insecure        Disables SSL validations.
  --ssl-client-cert SSL_CLIENT_CERT
                        Specify the path to the Client SSL certificate. 
                        Supports .cert and .pfx files.
  --ssl-client-key SSL_CLIENT_KEY
                        Specify the path to the Client SSL key (not needed 
                        for .pfx files).
  --ssl-client-passphrase SSL_CLIENT_PASSPHRASE
                        Specify the Client SSL passphrase (optional, needed 
                        for passphrase protected keys).
  -e ENVIRONMENT, --environment ENVIRONMENT
                        Specify a URL or Path to a Postman Environment
  -g GLOBALS, --globals GLOBALS
                        Specify a URL or Path to a file containing Postman 
                        Globals
  --folder FOLDER       Run a single folder from a collection
  -r REPORTERS, --reporters REPORTERS
                        Specify the reporters to use for this run.
  -n ITERATION_COUNT, --iteration-count ITERATION_COUNT
                        Define the number of iterations to run.
  -d ITERATION_DATA, --iteration-data ITERATION_DATA
                        Specify a data file to use for iterations (either 
                        json or csv)
  --export-environment [EXPORT_ENVIRONMENT]
                        Exports the environment to a file after completing 
                        the run
  --export-globals [EXPORT_GLOBALS]
                        Specify an output file to dump Globals before exiting
  --export-collection [EXPORT_COLLECTION]
                        Specify an output file to save the executed collection
  --delay-request DELAY_REQUEST
                        Specify the extent of delay between requests 
                        (milliseconds)
  --bail                Specify whether or not to gracefully stop a 
                        collection run on encountering the first error
  -x, --suppress-exit-code
                        Specify whether or not to override the default exit 
                        code for the current run
  --silent              Prevents newman from showing output to CLI
  --disable-unicode     Forces unicode compliant symbols to be replaced by 
                        their plain text equivalents
  --global-var GLOBAL_VAR
                        Allows the specification of global variables via the 
                        command line, in a key=value format
</code></pre>
]]></content>
  </entry>
  
</feed>
