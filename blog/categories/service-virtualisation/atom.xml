<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Service Virtualisation | Aby George A]]></title>
  <link href="http://www.abygeorgea.com/blog/categories/service-virtualisation/atom.xml" rel="self"/>
  <link href="http://www.abygeorgea.com/"/>
  <updated>2017-08-29T22:25:41+10:00</updated>
  <id>http://www.abygeorgea.com/</id>
  <author>
    <name><![CDATA[Aby George A]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Stubbing XML Responses Using Mountebank]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/04/27/stubbing-xml-responses-using-mountebank/"/>
    <updated>2017-04-27T05:55:51+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/04/27/stubbing-xml-responses-using-mountebank</id>
    <content type="html"><![CDATA[<p>Previous two blog post talked about how we can use mountebank for stubbing where responses are in json format . They can be accessed (<a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">here</a>) and (<a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2/">here</a>). We can use same approach for stubbing SOAP services using XML as well. In this post, I will explain how we can provide XML response using Mountebank .</p>

<p>Let us have a quick look into the files created. Before we begin, folder structure of various file as below</p>

<p><img src="/images/2017/04/27/Mountebank_XML_Response_Folder-Tree.jpg" alt="folderstructure" /></p>

<h4>Imposter.ejs</h4>

<p>The main Imposter file is
<code>plain Imposter.ejs
{
"imposters": [
&lt;% include Port4547.json %&gt;
]
}
</code></p>

<h4>Port4547.json</h4>

<p>This file specifies which port number to use and what all stubs needs to be created is as below
<code>plain Port4547.json
{
"port": 4547,
"protocol": "http",
"stubs": [
{
&lt;% include XMLStubGET.json %&gt;
},
{
&lt;% include XMLStubPOST.json %&gt;
}
]
}
</code></p>

<h4>XMLStubGET.json</h4>

<p>This is the first stub for this example and it looks for any request coming with the method &ldquo;GET&rdquo; and path &ldquo;/Blog.Api/[0-9]+/CustomerView&rdquo; , where [0-9]+ is regular expression of any numeric</p>

<pre><code class="plain XMLStubGET.json">"responses": [
{
"inject": "&lt;%-stringify(filename, 'ResponseInjection\\GetXMLStub.js') %&gt;"
}
],
"predicates": [
{
"matches": {
"method" : "GET",
"path" : "/Blog.Api/[0-9]+/CustomerView"
}
}
]
</code></pre>

<h4>XMLStubPOST.json</h4>

<p>This is the second stub for this example and it looks for any request coming with method &ldquo;POST&rdquo; and path &ldquo;/Blog.Api/XMLexamplePOST/[0-9]+&rdquo; , where [0-9]+ is regular expression of any numeric .It also needs a body as <Action>Insert</Action><Record>Customer1</Record></p>

<p>Note: If you have body in multi-line, then make sure to enter &ldquo;\n&rdquo; for new line</p>

<pre><code class="plain XMLStubPOST.json">"responses": [
{
"inject": "&lt;%-stringify(filename, 'ResponseInjection\\GetXMLStub-POST.js') %&gt;"
}
],
"predicates": [
{
"matches": {
"body" : "&lt;Action&gt;Insert&lt;/Action&gt;&lt;Record&gt;Customer1&lt;/Record&gt;",
"method" : "POST",
"path" : "/Blog.Api/XMLexamplePOST/[0-9]+"
}
}
]
</code></pre>

<h4>GetXMLStub.js</h4>

<p>Below js file create a response based on template mentioned and return the response with proper status. Please note that, we are not using &ldquo;Json.Parse&rdquo; here as we did for previous examples involving json.</p>

<pre><code class="plain GetXMLStub.js">function GetTemplateResponse (request, state, logger) {
response = "&lt;%- stringify(filename, 'StubTemplate\\CustomerDetails.xml') %&gt;"
return {
statusCode : 200,
headers: {
'Content-Type': 'application/xml; charset=utf-8'
},
body: response
};
}
</code></pre>

<h4>GetXMLStub-POST.js</h4>

<pre><code class="plain GetXMLStub-POST.js">function GetTemplateResponse (request, state, logger) {
response = "&lt;%- stringify(filename, 'StubTemplate\\RecordAdded.xml') %&gt;"
return {
statusCode : 200,
headers: {
'Content-Type': 'application/xml; charset=utf-8'
},
body: response
};
}
</code></pre>

<h4>CustomerDetails.XML</h4>

<p>This is the template for the first stub - GET example</p>

<pre><code class="plain XML">&lt;customer&gt;
  &lt;FirstName&gt;John&lt;/FirstName&gt;
  &lt;LastName&gt;Citizen&lt;/LastName&gt;
  &lt;Address&gt;Some St, Some State, Some Country&lt;/Address&gt;
  &lt;Email&gt;Test@test.com&lt;/Email&gt;
&lt;/customer&gt;
</code></pre>

<h4>RecordAdded.xml</h4>

<p>This is the template for the second stub - POST example</p>

<pre><code class="plain XML">&lt;Status&gt;Added&lt;/Status&gt;
&lt;Record&gt;Customer1&lt;/Record&gt;
</code></pre>

<p>After creating above files and keeping them as per directory structure is shown above, it is time to start mountebank</p>

<blockquote><p>mb &ndash;configfile SOAP-XMLStubExample/Imposter.ejs &ndash;allowInjection</p></blockquote>

<p>Note: Give the right path to Imposter.ejs . If you need to debug Mountebank, you can use below command at the end &ldquo; &ndash;loglevel debug&rdquo;</p>

<p>Now trigger a get request to <a href="http://localhost:4547/Blog.Api/3123/CustomerView.">http://localhost:4547/Blog.Api/3123/CustomerView.</a></p>

<p>This should match with our first predicate and should return the response mentioned</p>

<p>Mountebank_XML_Response_</p>

<p>Now trigger a POST request with a body . If predicates are matched, then it will respond with expected response as below</p>

<p><img src="/images/2017/04/27/Mountebank_XML_Response_PostmanRequest1.png" alt="PostManRequest" /></p>

<p>In Nut shell, creating a XML response is similar to creating json response. There are only minor differences in the js file which creates the response. The main difference is the omission of Json.Parse and also changing the response headers.</p>

<p>Above examples can be cloned from my GitHub repository <a href="https://github.com/abygeorgea/MountebankExamples">here</a>. After cloning the repository to local, just run RunMounteBankStubsWithSOAPXMLStubExampleData.bat file. Postman scripts can also be found inside PostmanCollections Folder to testing this</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mountebank - Creating a Response Based on a File Template and Modifying It Based on Request - PART 2]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/04/06/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2/"/>
    <updated>2017-04-06T20:24:20+00:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/04/06/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2</id>
    <content type="html"><![CDATA[<p>This is an extension to my previous blog about how we can use mountebank to create a stubbed response based on a template file . You can read about it <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">here</a>.  In this step by step example, I will explain how we will use mountebank to modify the response based on the request . Before we start, please ensure you are familiar with <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">Part1 </a>of the excercise. If you need to know more about mountebank and how to use mountebank , please read through <a href="/blog/2017/02/13/service-virtualisation-using-mountebank/">how to install mountebank </a> and <a href="/blog/2017/03/03/mountebank-your-first-service-virtualisation/">service virtualisation using mountebank</a>.</p>

<p>As in previous example, let us create Imposter.ejs and 4547.json . Contents of the Imposter.ejs is as below
``` plain Imposter.ejs</p>

<p>{
 &ldquo;imposters&rdquo;: [</p>

<p> &lt;% include 4547.json %></p>

<p> ]
}</p>

<pre><code>
Contents of 4547.json is as below



**4547.json**
</code></pre>

<p>{
 &ldquo;port&rdquo;: 4547,
 &ldquo;protocol&rdquo;: &ldquo;http&rdquo;,
 &ldquo;stubs&rdquo;: [</p>

<p>{
 &lt;% include  CustomerNotFound.json %>
 },
 {
  &lt;% include  CustomerFound.json %>
 }
 ]
 }</p>

<pre><code>


Now create CustomerFound.json
</code></pre>

<p> &ldquo;responses&rdquo;: [
 {
 &ldquo;inject&rdquo;: &ldquo;&lt;%-stringify(filename, &lsquo;ResponseInjection\GetCustomerFound.js&rsquo;) %>&rdquo;
 }</p>

<p> ],
 &ldquo;predicates&rdquo;: [
 {
 &ldquo;matches&rdquo;: {
 &ldquo;method&rdquo; : &ldquo;GET&rdquo;,
 &ldquo;path&rdquo; : &ldquo;/Blog.Api/[0-9]+/CustomerView&rdquo;
 }
 }
 ]</p>

<pre><code>


As we can see from above, if there is request which matches the predicates , then response will be dictated by the GetCustomerFound javascript file kept inside directory ResponseInjection. Predicate used here is a GET request which have a matching path of /Blog.Api/[0-9]+/CustomerView.

Contents of GetCustomerFound.js is
</code></pre>

<p>function GetTemplateResponse (request, state, logger) {</p>

<p>response = JSON.parse(&ldquo;&lt;%- stringify(filename, &lsquo;StubTemplate\CustomerFoundView.json&rsquo;) %>&rdquo;);
 var ext =require(&lsquo;../../../StubResponse/ResponseInjection/extractrequest&rsquo;);</p>

<p>var reqdata = ext.extractor(request);</p>

<p> response.data.customerID=reqdata.CustomerID;</p>

<p> return {
 statusCode : 200,
 headers: {
 &lsquo;Content-Type&rsquo;: &lsquo;application/json; charset=utf-8&rsquo;
 },
 body: response</p>

<p> };
}</p>

<pre><code>
The javascript file have a single function , which reads the stubbed response kept in template file . Then it calls another Javascript function to called "extractrequest". We will see the details of it soon. For now, it actually returns the customer number from the request . For eg, if request is "http://localhost:4547/Blog.Api/3123/CustomerView " then it return 3123 as customer ID. Once we extract the customer ID, then it will replace the customer ID in our template response with the value coming from request and return the response.

Let us take a close look at the extractrequest function.
</code></pre>

<p>module.exports = {extractor:function extractCIFAndPackageID (request) {</p>

<p>if(request &amp;&amp; request.path) {
var req = request.path.split(&lsquo;/&rsquo;);
if(req.length >2 &amp;&amp; req[1]) {
return { CustomerID: req[2] }
}
}</p>

<p>return null;
}}</p>

<pre><code>
This method will take the input parameter as the request and split it at "/" to get a an array . Then we will return the array[2] which is the customer ID from the request



Finally , the template response

**CustomerFoundView.json**
</code></pre>

<p>{
&ldquo;status&rdquo;: &ldquo;success&rdquo;,
&ldquo;code&rdquo;: 0,
&ldquo;message&rdquo;: &ldquo;&rdquo;,
&ldquo;data&rdquo;:
{</p>

<p>&ldquo;customerID&rdquo;: &ldquo;123&rdquo;,
&ldquo;firstName&rdquo;: &ldquo;John&rdquo;,
&ldquo;lastName&rdquo;: &ldquo;Citizen&rdquo;,
&ldquo;email&rdquo;: &ldquo;<a href="&#109;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#x4a;&#111;&#104;&#110;&#x2e;&#x43;&#x69;&#x74;&#105;&#x7a;&#x65;&#x6e;&#64;&#x61;&#x62;&#x63;&#97;&#98;&#97;&#x63;&#x61;&#x73;&#x2e;&#99;&#x6f;&#x6d;">&#x4a;&#111;&#x68;&#x6e;&#x2e;&#67;&#x69;&#x74;&#105;&#122;&#x65;&#110;&#x40;&#x61;&#x62;&#99;&#97;&#x62;&#97;&#99;&#97;&#115;&#46;&#x63;&#x6f;&#x6d;</a>&rdquo;</p>

<p>}</p>

<p>}</p>

<p>```</p>

<p>Now let us fire up mountebank</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/mountebank.png" alt="mountebank" /></p>

<p>Make few request using postman, which have different request parameter</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/customerfound1.png" alt="customerFound1" /></p>

<p>Another request</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/customerfound2.png" alt="CustomerFound2" /></p>

<p>In above two examples,we  can see the CustomerID field is response is updated with number extracted from request.</p>

<p>Now let us try another example , where request is <a href="http://localhost:4547/Blog.Api/1234542323/CustomerView">http://localhost:4547/Blog.Api/1234542323/CustomerView</a></p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/customernotfound2.png" alt="CustomerNotFound2" /></p>

<p>As you can see, we are getting a customer Not found response. This is due to the order of predicates we use. In our 4547.json, the order of response are as below.</p>

<ol>
<li><p> Customer Not found which has a predicate of &ldquo;/Blog.Api/1[0-9]+/CustomerView&rdquo;</p></li>
<li><p>Customer found which has a predicate of &ldquo;/Blog.Api/[0-9]+/CustomerView&rdquo;</p></li>
</ol>


<p>As you can see from above order, when a request comes through , mountebank will first match with predicate of first response and if it matches, it returns the response. If not, mountebank will keep trying with next one followed by all others. In this particular example, since our request have a customer ID of 1234542323, it matches with regular expression of first one ( 1[0-9]+)  and hence it return customer not found response.</p>

<p>In next blog post, I will provide more insights about how to extract request from different type of requests.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mountebank - Creating a Response Based on a File Template and Modifying It Based on Request - PART 1]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/04/06/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/"/>
    <updated>2017-04-06T19:43:44+00:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/04/06/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1</id>
    <content type="html"><![CDATA[<p>In the previous two blog post, I have explained about how to setup mountebank (<a href="/blog/2017/02/13/service-virtualisation-using-mountebank/">here</a>) and how to create a virtualised respone(<a href="/blog/2017/03/03/mountebank-your-first-service-virtualisation/">here</a>) . Now coming to more detailed use cases which we might encounter in daily life. In this blog post, I will explain how we can use mountebank to create a virtualised response based on a template response stored in a file and modifying certain fields in response based on the request coming through.</p>

<p>In below Step by Step example , I will have two mock responses for searching for a customer details. First response is when customer is not available in back end systems and second response is when customer details are found.</p>

<p>Before we start, below is folder structure which I have and in this blog post we are discussing about only one stubbed response, which is the NOT FOUND scenario.</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/folderstructure.png" alt="folderstructure" /></p>

<p>Let us first create the imposter.ejs file</p>

<pre><code class="plain Imposter.ejs">
{
"imposters": [

&lt;% include 4547.json %&gt;

]
}
</code></pre>

<p>Now let us create the file which specifies the port number where it should run and order of responses. Below code tells mountebank that port which it needs to listen for incoming request is 4547 and protocol is http. There are two set of mock responses planned.</p>

<pre><code class="plain 4545">{
"port": 4547,
"protocol": "http",
"stubs": [

{
&lt;% include CustomerNotFound.json %&gt;
},
{
&lt;% include CustomerFound.json %&gt;
}
]
} 
</code></pre>

<p>In this example, let us look at first mock response.</p>

<pre><code class="plain CustomerNotFOund.json">"responses": [
{
"inject": "&lt;%- stringify(filename, 'ResponseInjection\\GetCustomerNotFound.js') %&gt;"
}

],
"predicates": [
{
"matches": {
"method" : "GET",
"path" : "/Blog.Api/1[0-9]+/CustomerView"
}
}
]
</code></pre>

<p>From above response, we can infer below. When ever an http GET request come to port 4547 , with a path matching &ldquo;/Blog.Api/1[0-9]+/CustomerView', then we will call the Javascript function "GetCustomerNotFound.js&rdquo; which is kept inside a directory &ldquo;ResponseInjection&rdquo; in same location. It is also good to notice that , predicate is a regular expression ( hence use matches) and all request where 1 followed by any number of numeric will be returned with this response</p>

<p>The javascript function listed here is responsible for reading the sample template response and sending it back .</p>

<pre><code class="plain GetCustomerNotFound.js">function GetTemplateResponse (request, state, logger) {

response = JSON.parse("&lt;%- stringify(filename, 'StubTemplate\\CustomerNotFoundView.json') %&gt;");

return {
statusCode : 404,
headers: {
'Content-Type': 'application/json; charset=utf-8'
},
body: response

};
}
</code></pre>

<p>Above function reads a json response kept inside directory &ldquo;StubTemplate&rdquo; and convert it to json and return to mountebank. Since this is for a scenario where customer records are not found,we set the status code as 404. We can also set the headers if needed</p>

<p>The stub template is as below</p>

<pre><code class="plain CustomerNotFoundView.json">{
"status": "fail",
"code": "CUSTOMER_NOT_FOUND",
"message": "Customer details not found."

}
</code></pre>

<p>Now let us run mountebank</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/mountebank.png" alt="mountebank" /></p>

<p>Request through postman</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/notfound.png" alt="notfound.png" /></p>

<p>As you can see , the GET request matching with predicate is returning the stubbed response with status 404.</p>

<p>For real time usage for testing any web application which needs to get a 404 message from back end API calls, just point the end point to this local host end point and fire a request which matches the predicate.</p>

<p>Details of second response will be shared in next blog post</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mountebank - Your First Service Virtualisation]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/03/03/mountebank-your-first-service-virtualisation/"/>
    <updated>2017-03-03T11:46:48+00:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/03/03/mountebank-your-first-service-virtualisation</id>
    <content type="html"><![CDATA[<p>In current development world, there will be scenarios were both API and its consumers are developed in parallel. Inorder to decouple their dependencies, we can mock an api response using mountebank. In this example, I will explain how to get started with your first service virtualisation using mountebank. After installing mountebank as mentioned in <a href="/blog/2017/02/13/service-virtualisation-using-mountebank/">here (Install Mountebank)</a>, we will proceed with configuring mountebank. It can be done in few ways. The method which I explain below is by using file based configuration. This involve setting up an imposter file and a stub response</p>

<h2>How to Create a Stub</h2>

<ol>
<li><p>Navigate to mountebank installation path</p></li>
<li><p>Create a folder and name it as &ldquo;StubResponse&rdquo;. ( You can name it whatever you want)</p></li>
<li><p>Create two json file using notepad and save it as &ldquo;MockResponeForApiOne.json&rdquo; and &ldquo;MockResponeForApiTwo.json&rdquo;( Or what ever you want).</p></li>
<li><p>Copy paste below code to &ldquo;MockResponeForApiOne.json&rdquo; . Sample example only. Update the response and predicates to suite your need ( if required)</p></li>
</ol>


<pre><code class="plain MockResponseForApiOne.json">
"responses": [
 {
 "is": {
 "statusCode": 200,
 "body": {
 "Text":"Response ONE ","token":"username","expires_in":90
 }
 }
 }
 ],
 "predicates": [
 {
 "exists": {
 "body" :
 {
 "username": true,"password" : true
 },
 "method" : "POST",
 "path" : "/Apitesting/v1/test?type=ResponseOne"
 }
 }
 ]
</code></pre>

<p>-</p>

<ol>
<li>Copy paste below code to &ldquo;MockResponeForApiTwo.json&rdquo; . Sample example only. Update the response and predicates to suite your need ( if required)</li>
</ol>


<pre><code class="plain MockResponseForApiTwo.json"> "responses": [
 {
 "is": {
 "statusCode": 200,
 "body": {
 "Text":"Response TWO ","token":"emailAddress","expires_in":90
 }
 }
 }
 ],
 "predicates": [
 {
 "exists": {
 "body" :
 {
 "email": true,"password" : true
 },
 "method" : "POST",
 "path" : "/Apitesting/v1/test?type=ResponseTwo"
 }
 }
 ]
</code></pre>

<h2>How to create an Imposter</h2>

<ol>
<li><p>Create another file called test.json in same path as above</p></li>
<li><p>copy and paste below contents to it</p></li>
</ol>


<pre><code class="plain test.json">
{
"imposters": [
{
"port": 4547,
"protocol": "http",
"stubs": [
{
&lt;% include MockResponseForApiOne.json %&gt;
},
{
&lt;% include MockResponseForApiTwo.json %&gt;
}
]
}
]
}
</code></pre>

<h2>Let us have a close look into Imposter and stubs</h2>

<p>Responses – Contains an array of responses expected to return for the defined stub. In the above scenario the response will include status code as 200 and response body. For more info, <a href="http://www.mbtest.org/docs/api/contracts">http://www.mbtest.org/docs/api/contracts</a>
Predicates – is an array of predicates which will be used during matching process. Predicate object can be quite complex, it supports lots of different matching techniques.
For more info, <a href="http://www.mbtest.org/docs/api/predicates">http://www.mbtest.org/docs/api/predicates</a></p>

<h2>Let&rsquo;s Mock it</h2>

<p>Once all required files are created and saved, mountebank can be started by following command in command prompt , after navigating to installation folder of mountebank</p>

<pre><code class="">
mb --configfile StubResponse/test.json
</code></pre>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/03/cmd.jpg" alt="cmd.jpg" /></p>

<p>Once mountebank is started, we can verify it by navigating to path <a href="http://localhost:2525/imposters">http://localhost:2525/imposters</a></p>

<p>It will list out all active ports and a list of stubs available</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/03/imposter.jpg" alt="imposter" /></p>

<h2>Test It</h2>

<p>Once we complete above steps, mountebank is ready with stubs. Now comes the part to test it and use. You can use any api testing tool ( Postman, soapUi etc ) for testing this. Just send the request matching the predicates and look for the responses</p>

<p>Below are the screenshot of Postman request</p>

<p><strong>Requesting for First API.</strong></p>

<p>Predicate of response One says that , request has to be of type POST, body of request should have &ldquo;username&rdquo; and &ldquo;password&rdquo; . Path of the request should have /Apitesting/v1/test?type=ResponseOne"</p>

<p>Now construct a postman request matching above and fire it</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/03/bgone.jpg" alt="bgone" /></p>

<p><strong>Request for second API</strong></p>

<p>Predicate of response One says that , request has to be of type POST, body of request should have &ldquo;<strong>email</strong>&rdquo; and &ldquo;password&rdquo; . Path of the request should have /Apitesting/v1/test?type=Response<strong>Two</strong>"</p>

<p>Now construct a postman request matching above and fire it</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/03/bgtwo.jpg" alt="bgtwo" /></p>

<p>As you can see, both request has succesfully received expected response message</p>

<p>For actual development usage, just point your application to this localhost URL and start consuming virtualised API</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service Virtualisation Using Mountebank]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/02/13/service-virtualisation-using-mountebank/"/>
    <updated>2017-02-13T11:13:58+00:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/02/13/service-virtualisation-using-mountebank</id>
    <content type="html"><![CDATA[<h1>What is Mountebank?</h1>

<blockquote>As per mbtest.org "_mountebank is the first open source tool to provide cross-platform, multi-protocol test doubles over the wire. Simply point your application under test to mountebank instead of the real dependency, and test like you would with traditional stubs and mocks_"</blockquote>


<p>In short mountebank is a open source service virtualisation tool . Mountebank uses imposters to act as on demand test doubles. Hence our test cases communicate to Mountebank and mountebank responds back with relevant stubs as defined.</p>

<h1>How to Setup Mountebank ?</h1>

<p>Installation can be done via two methods</p>

<h3>npm</h3>

<p>Mountebank can be installed as a npm package. Node.js should be installed for this option to work</p>

<pre><code>&lt;code&gt;npm install -g mountebank&lt;/code&gt;
</code></pre>

<h3>Self contained Installation file</h3>

<p>OS Specific installation file can be downloaded from <a href="http://www.mbtest.org/docs/install">Download</a></p>

<p>Note: Please read through the windows path limitation mentioned in above link</p>
]]></content>
  </entry>
  
</feed>
