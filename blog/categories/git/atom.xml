<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | Aby George A]]></title>
  <link href="http://www.abygeorgea.com/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://www.abygeorgea.com/"/>
  <updated>2017-08-22T21:53:29+10:00</updated>
  <id>http://www.abygeorgea.com/</id>
  <author>
    <name><![CDATA[Aby George A]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Squash Commits in Git]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/06/15/how-to-squash-commits-in-git/"/>
    <updated>2017-06-15T05:46:39+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/06/15/how-to-squash-commits-in-git</id>
    <content type="html"><![CDATA[<p>Very often we will be committing smaller pieces of work in our local machine as we go. However before we push them to a centralized repository, we may have to combine these small commits to single large commit, which makes sense for rest of the team. I will explain how this can be achieved by using interactive rebasing.</p>

<p>To start with, let us assume the initial commits history look like below. It have 4 minor commits done to the same file.
<img src="/images/2017/06/15/HowToSquashCommits_image1.png" alt="Initial Commit Structure" /></p>

<p>Now we need to squash last for commits into a single commit. The command required for that is as below. This tells git to rebase head with previous 4 commits in an interactive mode.</p>

<pre><code>    $ git rebase -i HEAD~4
</code></pre>

<p>This will pop up another editor with details of last 4 commits and some description about possible actions on this. Initially, all of them will have a default value of PICK. Since we are trying to squash commits together, we can select one of the commits as PICK and rest all needs to be changed as SQUASH. Save and close the editor once all changes are made.</p>

<p><img src="/images/2017/06/15/HowToSquashCommits_image2.png" alt="Interactive Rebasing" /></p>

<p>After this, another popup will appear with comments given for each of the commits. We can comment out unnecessary comments by using <code>#</code> and also modify required comments as we need. In below screen, I have modified comments for the first commit and commented out rest all. Save and close the editor once all changes are made.</p>

<p><img src="/images/2017/06/15/HowToSquashCommits_image3.png" alt="Selecting comments" /></p>

<p>Now Git will continue rebasing and it will squash all commits as selected in the previous step.</p>

<p><img src="/images/2017/06/15/HowToSquashCommits_image4.png" alt="Git rebase" /></p>

<p>If we look at commit history, we can see that commits are now squashed to single commit.</p>

<p><img src="/images/2017/06/15/HowToSquashCommits_image5.png" alt="Squashed Result" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git - How to Solve Filename Too Long Error]]></title>
    <link href="http://www.abygeorgea.com/blog/2016/09/23/git-how-to-solve-filename-too-long-error/"/>
    <updated>2016-09-23T06:31:03+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2016/09/23/git-how-to-solve-filename-too-long-error</id>
    <content type="html"><![CDATA[<p>Git for windows is normally shipped with long path support disabled due to mysys not supporting file path/name greater than 260 character. While cloning repository with large nested directory structute may cause error &ldquo;file name too long&rdquo;. This can be fixed by below command. It can be executed using powershell or cmd directly in project ( or anywhere if git variable is available)</p>

<pre><code class="plain cmd.exe">git config --system core.longpaths true
</code></pre>
]]></content>
  </entry>
  
</feed>
