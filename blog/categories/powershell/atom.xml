<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Powershell | Aby George A]]></title>
  <link href="http://www.abygeorgea.com/blog/categories/powershell/atom.xml" rel="self"/>
  <link href="http://www.abygeorgea.com/"/>
  <updated>2018-09-08T23:18:07+10:00</updated>
  <id>http://www.abygeorgea.com/</id>
  <author>
    <name><![CDATA[Aby George A]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running Powershell Remotely]]></title>
    <link href="http://www.abygeorgea.com/blog/2018/09/05/running-powershell-remotely/"/>
    <updated>2018-09-05T22:46:14+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2018/09/05/running-powershell-remotely</id>
    <content type="html"><![CDATA[<p>Code snippet for running power shell on a remote machine. Loosely based on blog post <a href="https://com2kid.wordpress.com/2011/09/22/remotely-executing-commands-in-powershell-using-c/">here</a> and <a href="https://www.codeproject.com/Articles/773685/Enable-Remote-PowerShell-Execution-in-Csharp">here</a></p>

<p>Add reference to System.Management.Automation</p>

<pre><code class="csharp">
using System.Management.Automation; 
using System.Management.Automation.Runspaces;    


  internal void runPowershellRemotely(string location, string scriptToBeRun)
        {
            string userName = ConfigurationManager.AppSettings["RemoteMachineLogonUser"];
            string password = ConfigurationManager.AppSettings["RemoteMachineUserPassword"]; 
           var securestring = new SecureString();
            foreach (Char c in password){
                securestring.AppendChar(c);
            }

            PSCredential creds = new PSCredential(userName, securestring);
            // Remove logging if not needed
            log.Info(String.Format("\tPOWERSHEL : Running Powershell {0} at location {1}", scriptToBeRun, location));
            WSManConnectionInfo connectionInfo = new WSManConnectionInfo();

           connectionInfo.ComputerName = ConfigurationManager.AppSettings["RemoteMachine"];
            connectionInfo.Credential = creds;
            Runspace runspace = RunspaceFactory.CreateRunspace(connectionInfo);
            runspace.Open();
            using (PowerShell ps = PowerShell.Create())
            {
                ps.Runspace = runspace;
                ps.AddScript(@"cd "+ location);
                ps.AddScript(scriptToBeRun);
                try
                {
                    var results = ps.Invoke();
                    log.Info("\tPOWERSHEL : Results from Powershell Script is ---------------------------");
                    foreach(var x in results)
                    {
                        log.Info(x.ToString());
                    }
                    log.Info("\tPOWERSHEL : End of results--------------------------------- ---------------------------");
                }
                catch (Exception e)
                {
                    log.Error("\tPOWERSHEL : Exception from running Powershell Script is" + e.ToString());
                }

            }
            runspace.Close();
        }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Powershell - Remove Entire Directory and It's Content]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/05/02/powershell-remove-entire-directory-and-its-content/"/>
    <updated>2017-05-02T06:27:27+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/05/02/powershell-remove-entire-directory-and-its-content</id>
    <content type="html"><![CDATA[<p>The PowerShell command to remove an entire directory and its contents ( including sub folders and files) is below</p>

<pre><code class="plain cmd.exe">rm -Rf pathToDirectoryToBeRemoved/
</code></pre>

<p>R flag denotes to run “rm” command recursively . “f” flag denotes to run in forcefully. We can even replace “f” with “v” for verbose mode and “i” for interactive mode.</p>

<p>Note: Above command can also be used to delete files which have long path ( more than 260 characters)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Powershell - Copying Folders and Files]]></title>
    <link href="http://www.abygeorgea.com/blog/2016/10/10/powershell-copying-folders-and-files/"/>
    <updated>2016-10-10T06:47:54+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2016/10/10/powershell-copying-folders-and-files</id>
    <content type="html"><![CDATA[<p>Two options for copying files are below.</p>

<ul>
<li>Robocopy - More details can be found at <a href="https://technet.microsoft.com/en-us/library/cc733145.aspx">Robocopy</a></li>
<li>Copy_Item cmdlet - More details can be found at <a href="https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.management/copy-item">Copy-Item</a></li>
</ul>


<h3>Copying Folder structure Only</h3>

<pre><code class="plain">$source = "C:\tools\DevKit2\octopress-blog\source"
$dest = "D:\delete"
Copy-Item $source $dest -Filter {PSIsContainer} -Recurse -Force

#OR
robocopy $source $dest /e /xf *.*

# /e denotes all folder including empty folders. /xf denotes all files except one of format *.*
# /e can be replaced with /s for ignoring empty folders
</code></pre>

<h3>Flattening Folder structure - Copy all files from nested folders to a single folder</h3>

<pre><code class="plain">$source = "C:\tools\DevKit2\octopress-blog\source"
$dest = "D:\delete"
# Below is required only if we need to create destination folder. Uncomment below line if folder needs to be created
#New-Item $dest -type directory 

Get-ChildItem $source -Recurse | `
    Where-Object { $_.PSIsContainer -eq $False } | `
    ForEach-Object {Copy-Item -Path $_.Fullname -Destination $dest -Force} 
</code></pre>

<h3>Copy same folder structure</h3>

<pre><code class="plain">$source = "C:\tools\DevKit2\octopress-blog\source"
$dest = "D:\delete"
robocopy $source $dest /e
</code></pre>
]]></content>
  </entry>
  
</feed>
