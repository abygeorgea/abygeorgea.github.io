<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mountebank | Aby George A]]></title>
  <link href="http://www.abygeorgea.com/blog/categories/mountebank/atom.xml" rel="self"/>
  <link href="http://www.abygeorgea.com/"/>
  <updated>2017-11-16T10:34:46+11:00</updated>
  <id>http://www.abygeorgea.com/</id>
  <author>
    <name><![CDATA[Aby George A]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mountebank - Adding Delay to Response]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/11/16/mountebank-adding-delay-to-response/"/>
    <updated>2017-11-16T09:59:17+11:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/11/16/mountebank-adding-delay-to-response</id>
    <content type="html"><![CDATA[<p>In previous blog post, I have explained about how to create a json response in mountebank. You can read about that <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">here</a> and <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2/">here</a>. Recently , I had to test a scenario about what will happen to application if downstream API response is delayed for some time . Let us have a look about how we can use mountebank to simulate this scenario.</p>

<p>Mountebank supports adding latency to response by adding a behaviour. You can read about that <a href="http://www.mbtest.org/docs/api/behaviors">here</a> . Let us try to implement the wait behaviour in one of the previous examples . This is a slight modification of the files used as part of examples mentioned <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">here</a> and <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2/">here</a>.  You can clone my github repo and look at &ldquo;ExamplesForWaitBehaviour&rdquo; for the files.</p>

<p>The only change which we need is to add a behavior to the response. This is added in &ldquo;CustomerFound.json&rdquo; file. After injecting file, we need to add behavior for waiting 5000 milliseconds.</p>

<pre><code>
"responses": [
{
"inject": "&lt;%-stringify(filename, 'ResponseInjection\\GetCustomerFound.js') %&gt;",
"_behaviors": {
    "wait": 5000
  }
}
],
"predicates": [
{
"matches": {
"method" : "GET",
"path" : "/Blog.Api/[0-9]+/CustomerView"
}
}
]
</code></pre>

<p>Now run Mountebank. If you are using the GitHub repo, you can do this by running RunMounteBankStubsWithExampleForWait.bat file. Else run below command inside the directory where mountebank is available. If needed, modify the path to Imposter.ejs as required.</p>

<pre><code>mb --configfile ExamplesForWaitBehaviour/Imposter.ejs --allowInjection
</code></pre>

<p>When we trigger a request via postman, we will get a response after specified delay + time for getting a response.  Have a look at response time in below screenshot. Response time is more than 5000 ms.</p>

<p><img src="/images/2017/11/16/Mountebank_Adding_Delay_PostmanRequest1.png" alt="PostManRequest" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extracting Substring Using Javascript]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/07/21/extracting-substring-using-javascript/"/>
    <updated>2017-07-21T06:09:53+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/07/21/extracting-substring-using-javascript</id>
    <content type="html"><![CDATA[<p>In previous blogs <a href="/blog/2017/04/27/stubbing-xml-responses-using-mountebank/">here</a> , I have explained how we return a XML response using mountebank. However , most of the time, we will have to make some modification to the template response before returning a response. Say for example, we may have to replace details like timestamp, or use an input from request parameter and update that in response etc.</p>

<p>One of the easiest way to do this without using other frameworks like xml2js etc is to extract the substring between the node values and replace it . Below is a code snippet which will help to achieve this</p>

<p>The sample xml which we need to return is</p>

<pre><code>&lt;Status&gt;Added&lt;/Status&gt;
&lt;GeneratedID&gt;12345&lt;/GeneratedID&gt;
</code></pre>

<p>In above example, assume that we need to replace the inserted record value every time based on the request coming through . We can do that by below</p>

<pre><code class="javascript">
var xmldata = "&lt;Status&gt;Added&lt;/Status&gt;\r\n&lt;GeneratedID&gt;12345&lt;/GeneratedID&gt;"

var generatedId = xmldata.match(new RegExp("&lt;GeneratedID&gt;"+"(.*)"+"&lt;/GeneratedID&gt;"));
console.log(generatedId);
// Output will be as below. from Array we can extract the substring, index of its location etc
/*
[ '&lt;GeneratedID&gt;12345&lt;/GeneratedID&gt;',
  '12345',
  index: 24,
  input: '&lt;Status&gt;Added&lt;/Status&gt;\r\n&lt;GeneratedID&gt;12345&lt;/GeneratedID&gt;' ]
  */

//so extract data from first location to get substring  
generatedId = xmldata.match(new RegExp("&lt;GeneratedID&gt;"+"(.*)"+"&lt;/GeneratedID&gt;"))[1];
console.log(generatedId);
//Above will print "12345" , which is the expected value
// This can be used for extracting value of xml nodes

//if we need to replace this with another value ( possibly coming from request parameter)
var result = xmldata.replace(generatedId, "99999");
console.log(result);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Predicates in Mountebank]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/07/15/predicates-in-mountebank/"/>
    <updated>2017-07-15T21:07:40+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/07/15/predicates-in-mountebank</id>
    <content type="html"><![CDATA[<p>Predicates in Mountebank imposter files is a pretty powerful way to configure stubs. It helps us to return different responses based on the request parameters like type, query string , headers, body etc. Let us have some quick look at extracting values from request</p>

<h3>Based on Query String</h3>

<p>Below is an example of extracting the records based on query string.
If the request is like <code>path?customerId=123&amp;customerId=456&amp;email=abc.com</code>
Note: This is slightly modified version of code in mbtest.org</p>

<pre><code>{
  "port": 4547,
  "protocol": "http",
  "stubs": [
    {
      "predicates": [{
        "equals": {
          "query": { "customerId": ["123", "456"] }
        }
      }],
      "responses": [{
        "is": {
          "body": "Customer ID is either 123 or 456"
        }
      }]
    },
    {
      "predicates": [{
        "equals": {
          "query": { 
            "customerId": "123",
            "email" :"abc.com"
             }
        }
      }],
      "responses": [{
        "is": {
          "body": "Customer ID is 123 and email is abc.com"
        }
      }]
    }
  ]
}
</code></pre>

<h3>Based on Header Content</h3>

<p>If input data is shared through values in header, that can be extracted. Below snippet is directly from mbtest.org</p>

<pre><code>{
  "port": 4545,
  "protocol": "http",
  "stubs": [
    {
      "responses": [{ "is": { "statusCode": 400 } }],
      "predicates": [
        {
          "equals": {
            "method": "POST",
            "path": "/test",
            "query": {
              "first": "1",
              "second": "2"
            },
            "headers": {
              "Accept": "text/plain"
            }
          }
        },
        {
          "equals": { "body": "hello, world" },
          "caseSensitive": true,
          "except": "!$"
        }
      ]
    }
   ]
 }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stubbing XML Responses Using Mountebank]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/04/27/stubbing-xml-responses-using-mountebank/"/>
    <updated>2017-04-27T05:55:51+10:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/04/27/stubbing-xml-responses-using-mountebank</id>
    <content type="html"><![CDATA[<p>Previous two blog post talked about how we can use mountebank for stubbing where responses are in json format . They can be accessed (<a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">here</a>) and (<a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2/">here</a>). We can use same approach for stubbing SOAP services using XML as well. In this post, I will explain how we can provide XML response using Mountebank .</p>

<p>Let us have a quick look into the files created. Before we begin, folder structure of various file as below</p>

<p><img src="/images/2017/04/27/Mountebank_XML_Response_Folder-Tree.jpg" alt="folderstructure" /></p>

<h4>Imposter.ejs</h4>

<p>The main Imposter file is
<code>plain Imposter.ejs
{
"imposters": [
&lt;% include Port4547.json %&gt;
]
}
</code></p>

<h4>Port4547.json</h4>

<p>This file specifies which port number to use and what all stubs needs to be created is as below
<code>plain Port4547.json
{
"port": 4547,
"protocol": "http",
"stubs": [
{
&lt;% include XMLStubGET.json %&gt;
},
{
&lt;% include XMLStubPOST.json %&gt;
}
]
}
</code></p>

<h4>XMLStubGET.json</h4>

<p>This is the first stub for this example and it looks for any request coming with the method &ldquo;GET&rdquo; and path &ldquo;/Blog.Api/[0-9]+/CustomerView&rdquo; , where [0-9]+ is regular expression of any numeric</p>

<pre><code class="plain XMLStubGET.json">"responses": [
{
"inject": "&lt;%-stringify(filename, 'ResponseInjection\\GetXMLStub.js') %&gt;"
}
],
"predicates": [
{
"matches": {
"method" : "GET",
"path" : "/Blog.Api/[0-9]+/CustomerView"
}
}
]
</code></pre>

<h4>XMLStubPOST.json</h4>

<p>This is the second stub for this example and it looks for any request coming with method &ldquo;POST&rdquo; and path &ldquo;/Blog.Api/XMLexamplePOST/[0-9]+&rdquo; , where [0-9]+ is regular expression of any numeric .It also needs a body as <Action>Insert</Action><Record>Customer1</Record></p>

<p>Note: If you have body in multi-line, then make sure to enter &ldquo;\n&rdquo; for new line</p>

<pre><code class="plain XMLStubPOST.json">"responses": [
{
"inject": "&lt;%-stringify(filename, 'ResponseInjection\\GetXMLStub-POST.js') %&gt;"
}
],
"predicates": [
{
"matches": {
"body" : "&lt;Action&gt;Insert&lt;/Action&gt;&lt;Record&gt;Customer1&lt;/Record&gt;",
"method" : "POST",
"path" : "/Blog.Api/XMLexamplePOST/[0-9]+"
}
}
]
</code></pre>

<h4>GetXMLStub.js</h4>

<p>Below js file create a response based on template mentioned and return the response with proper status. Please note that, we are not using &ldquo;Json.Parse&rdquo; here as we did for previous examples involving json.</p>

<pre><code class="plain GetXMLStub.js">function GetTemplateResponse (request, state, logger) {
response = "&lt;%- stringify(filename, 'StubTemplate\\CustomerDetails.xml') %&gt;"
return {
statusCode : 200,
headers: {
'Content-Type': 'application/xml; charset=utf-8'
},
body: response
};
}
</code></pre>

<h4>GetXMLStub-POST.js</h4>

<pre><code class="plain GetXMLStub-POST.js">function GetTemplateResponse (request, state, logger) {
response = "&lt;%- stringify(filename, 'StubTemplate\\RecordAdded.xml') %&gt;"
return {
statusCode : 200,
headers: {
'Content-Type': 'application/xml; charset=utf-8'
},
body: response
};
}
</code></pre>

<h4>CustomerDetails.XML</h4>

<p>This is the template for the first stub - GET example</p>

<pre><code class="plain XML">&lt;customer&gt;
  &lt;FirstName&gt;John&lt;/FirstName&gt;
  &lt;LastName&gt;Citizen&lt;/LastName&gt;
  &lt;Address&gt;Some St, Some State, Some Country&lt;/Address&gt;
  &lt;Email&gt;Test@test.com&lt;/Email&gt;
&lt;/customer&gt;
</code></pre>

<h4>RecordAdded.xml</h4>

<p>This is the template for the second stub - POST example</p>

<pre><code class="plain XML">&lt;Status&gt;Added&lt;/Status&gt;
&lt;Record&gt;Customer1&lt;/Record&gt;
</code></pre>

<p>After creating above files and keeping them as per directory structure is shown above, it is time to start mountebank</p>

<blockquote><p>mb &ndash;configfile SOAP-XMLStubExample/Imposter.ejs &ndash;allowInjection</p></blockquote>

<p>Note: Give the right path to Imposter.ejs . If you need to debug Mountebank, you can use below command at the end &ldquo; &ndash;loglevel debug&rdquo;</p>

<p>Now trigger a get request to <a href="http://localhost:4547/Blog.Api/3123/CustomerView.">http://localhost:4547/Blog.Api/3123/CustomerView.</a></p>

<p>This should match with our first predicate and should return the response mentioned</p>

<p>Mountebank_XML_Response_</p>

<p>Now trigger a POST request with a body . If predicates are matched, then it will respond with expected response as below</p>

<p><img src="/images/2017/04/27/Mountebank_XML_Response_PostmanRequest1.png" alt="PostManRequest" /></p>

<p>In Nut shell, creating a XML response is similar to creating json response. There are only minor differences in the js file which creates the response. The main difference is the omission of Json.Parse and also changing the response headers.</p>

<p>Above examples can be cloned from my GitHub repository <a href="https://github.com/abygeorgea/MountebankExamples">here</a>. After cloning the repository to local, just run RunMounteBankStubsWithSOAPXMLStubExampleData.bat file. Postman scripts can also be found inside PostmanCollections Folder to testing this</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mountebank - Creating a Response Based on a File Template and Modifying It Based on Request - PART 2]]></title>
    <link href="http://www.abygeorgea.com/blog/2017/04/06/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2/"/>
    <updated>2017-04-06T20:24:20+00:00</updated>
    <id>http://www.abygeorgea.com/blog/2017/04/06/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-2</id>
    <content type="html"><![CDATA[<p>This is an extension to my previous blog about how we can use mountebank to create a stubbed response based on a template file . You can read about it <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">here</a>.  In this step by step example, I will explain how we will use mountebank to modify the response based on the request . Before we start, please ensure you are familiar with <a href="/blog/2017/04/07/mountebank-creating-a-response-based-on-a-file-template-and-modifying-it-based-on-request-part-1/">Part1 </a>of the excercise. If you need to know more about mountebank and how to use mountebank , please read through <a href="/blog/2017/02/13/service-virtualisation-using-mountebank/">how to install mountebank </a> and <a href="/blog/2017/03/03/mountebank-your-first-service-virtualisation/">service virtualisation using mountebank</a>.</p>

<p>As in previous example, let us create Imposter.ejs and 4547.json . Contents of the Imposter.ejs is as below
``` plain Imposter.ejs</p>

<p>{
 &ldquo;imposters&rdquo;: [</p>

<p> &lt;% include 4547.json %></p>

<p> ]
}</p>

<pre><code>
Contents of 4547.json is as below



**4547.json**
</code></pre>

<p>{
 &ldquo;port&rdquo;: 4547,
 &ldquo;protocol&rdquo;: &ldquo;http&rdquo;,
 &ldquo;stubs&rdquo;: [</p>

<p>{
 &lt;% include  CustomerNotFound.json %>
 },
 {
  &lt;% include  CustomerFound.json %>
 }
 ]
 }</p>

<pre><code>


Now create CustomerFound.json
</code></pre>

<p> &ldquo;responses&rdquo;: [
 {
 &ldquo;inject&rdquo;: &ldquo;&lt;%-stringify(filename, &lsquo;ResponseInjection\GetCustomerFound.js&rsquo;) %>&rdquo;
 }</p>

<p> ],
 &ldquo;predicates&rdquo;: [
 {
 &ldquo;matches&rdquo;: {
 &ldquo;method&rdquo; : &ldquo;GET&rdquo;,
 &ldquo;path&rdquo; : &ldquo;/Blog.Api/[0-9]+/CustomerView&rdquo;
 }
 }
 ]</p>

<pre><code>


As we can see from above, if there is request which matches the predicates , then response will be dictated by the GetCustomerFound javascript file kept inside directory ResponseInjection. Predicate used here is a GET request which have a matching path of /Blog.Api/[0-9]+/CustomerView.

Contents of GetCustomerFound.js is
</code></pre>

<p>function GetTemplateResponse (request, state, logger) {</p>

<p>response = JSON.parse(&ldquo;&lt;%- stringify(filename, &lsquo;StubTemplate\CustomerFoundView.json&rsquo;) %>&rdquo;);
 var ext =require(&lsquo;../../../StubResponse/ResponseInjection/extractrequest&rsquo;);</p>

<p>var reqdata = ext.extractor(request);</p>

<p> response.data.customerID=reqdata.CustomerID;</p>

<p> return {
 statusCode : 200,
 headers: {
 &lsquo;Content-Type&rsquo;: &lsquo;application/json; charset=utf-8&rsquo;
 },
 body: response</p>

<p> };
}</p>

<pre><code>
The javascript file have a single function , which reads the stubbed response kept in template file . Then it calls another Javascript function to called "extractrequest". We will see the details of it soon. For now, it actually returns the customer number from the request . For eg, if request is "http://localhost:4547/Blog.Api/3123/CustomerView " then it return 3123 as customer ID. Once we extract the customer ID, then it will replace the customer ID in our template response with the value coming from request and return the response.

Let us take a close look at the extractrequest function.
</code></pre>

<p>module.exports = {extractor:function extractCIFAndPackageID (request) {</p>

<p>if(request &amp;&amp; request.path) {
var req = request.path.split(&lsquo;/&rsquo;);
if(req.length >2 &amp;&amp; req[1]) {
return { CustomerID: req[2] }
}
}</p>

<p>return null;
}}</p>

<pre><code>
This method will take the input parameter as the request and split it at "/" to get a an array . Then we will return the array[2] which is the customer ID from the request



Finally , the template response

**CustomerFoundView.json**
</code></pre>

<p>{
&ldquo;status&rdquo;: &ldquo;success&rdquo;,
&ldquo;code&rdquo;: 0,
&ldquo;message&rdquo;: &ldquo;&rdquo;,
&ldquo;data&rdquo;:
{</p>

<p>&ldquo;customerID&rdquo;: &ldquo;123&rdquo;,
&ldquo;firstName&rdquo;: &ldquo;John&rdquo;,
&ldquo;lastName&rdquo;: &ldquo;Citizen&rdquo;,
&ldquo;email&rdquo;: &ldquo;<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x4a;&#111;&#x68;&#x6e;&#46;&#67;&#105;&#116;&#x69;&#x7a;&#x65;&#110;&#64;&#97;&#98;&#x63;&#x61;&#98;&#x61;&#99;&#x61;&#115;&#x2e;&#x63;&#x6f;&#109;">&#x4a;&#x6f;&#x68;&#110;&#x2e;&#67;&#105;&#116;&#x69;&#122;&#101;&#110;&#64;&#x61;&#x62;&#99;&#x61;&#x62;&#97;&#99;&#97;&#x73;&#46;&#x63;&#x6f;&#x6d;</a>&rdquo;</p>

<p>}</p>

<p>}</p>

<p>```</p>

<p>Now let us fire up mountebank</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/mountebank.png" alt="mountebank" /></p>

<p>Make few request using postman, which have different request parameter</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/customerfound1.png" alt="customerFound1" /></p>

<p>Another request</p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/customerfound2.png" alt="CustomerFound2" /></p>

<p>In above two examples,we  can see the CustomerID field is response is updated with number extracted from request.</p>

<p>Now let us try another example , where request is <a href="http://localhost:4547/Blog.Api/1234542323/CustomerView">http://localhost:4547/Blog.Api/1234542323/CustomerView</a></p>

<p><img src="https://automationtestingtips.files.wordpress.com/2017/04/customernotfound2.png" alt="CustomerNotFound2" /></p>

<p>As you can see, we are getting a customer Not found response. This is due to the order of predicates we use. In our 4547.json, the order of response are as below.</p>

<ol>
<li><p> Customer Not found which has a predicate of &ldquo;/Blog.Api/1[0-9]+/CustomerView&rdquo;</p></li>
<li><p>Customer found which has a predicate of &ldquo;/Blog.Api/[0-9]+/CustomerView&rdquo;</p></li>
</ol>


<p>As you can see from above order, when a request comes through , mountebank will first match with predicate of first response and if it matches, it returns the response. If not, mountebank will keep trying with next one followed by all others. In this particular example, since our request have a customer ID of 1234542323, it matches with regular expression of first one ( 1[0-9]+)  and hence it return customer not found response.</p>

<p>In next blog post, I will provide more insights about how to extract request from different type of requests.</p>
]]></content>
  </entry>
  
</feed>
